<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android MVVM (1) 簡介</title>
      <link href="/2019/04/02/Android%20MVVM%20(1)%20%E7%B0%A1%E4%BB%8B/"/>
      <url>/2019/04/02/Android%20MVVM%20(1)%20%E7%B0%A1%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>參考資料<br><br><a href="https://tech.meituan.com/2016/11/11/android-mvvm.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/11/11/android-mvvm.html</a></p><h2 id="1-MVC、MVP、MVVM-架構模式-簡介"><a href="#1-MVC、MVP、MVVM-架構模式-簡介" class="headerlink" title="1.MVC、MVP、MVVM 架構模式 簡介"></a>1.MVC、MVP、MVVM 架構模式 簡介</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul><li>View：xml佈局文件</li><li>Model：實體模型（數據的獲取、存儲、數據狀態變化）</li><li>Controllor：Activity業務邏輯，數據處理和UI處理</li></ul><p>由於代表View的XML視圖功能太弱，導致大量處理View的邏輯隻能寫在Activity中，這樣Activity就充當了View和Controller兩個角色。這個MVC結構最終其實只是一個 Model-View的結構</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><ul><li>View: Activity和XML，負責View的繪製以及與用戶的交互 </li><li>Model: 實體模型（數據的獲取、存儲、數據狀態變化）</li><li>Presenter: 負責完成View與Model間的交互和業務邏輯</li></ul><p>通過一個抽象的View接口（不是真正的View層）將Presenter與真正的View層進行解耦。Persenter持有該View接口，對該接口進行操作，而不是直接操作View層。這樣就可以把視圖操作和業務邏輯解耦，從而讓Activity成為真正的View層。</p><p>弊端：<br><br>1.P層與V層是通過接口進行交互的，會存在大量接口代碼<br><br>2.以UI為驅動的模型，使用需考慮控件的引用、UI線程與Activity的生命周期<br><br>3.UI若改變，牽扯的更新UI的接口就必須得換<br><br>4.複雜的業務同時也可能會導致P層太大，代碼臃腫的問題依然不能解決</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul><li>Model: 實體模型（數據的獲取、存儲、數據狀態變化）</li><li>View: 對應於Activity和xml，負責View的繪製以及與用戶交互</li><li>ViewModel(VM): 負責完成View於Model間的交互,負責業務邏輯</li></ul><p>利用數據綁定(Data Binding)、依賴屬性(Dependency Property)、命令(Command)、路由事件(Routed Event)達成以下特性</p><h4 id="數據驅動"><a href="#數據驅動" class="headerlink" title="數據驅動"></a>數據驅動<br></h4><p>在MVVM中，數據變化後會自動更新UI，UI的改變也能自動反饋到數據層，數據成為主導因素。這樣MVVM層在業務邏輯處理中只要關心數據，不需要直接和UI打交道，在業務處理過程中簡單方便很多。</p><h4 id="低耦合度、可複用性、團隊協作容易"><a href="#低耦合度、可複用性、團隊協作容易" class="headerlink" title="低耦合度、可複用性、團隊協作容易"></a>低耦合度、可複用性、團隊協作容易<br></h4><p>數據和業務邏輯處於一個獨立的ViewModel中，ViewModel只需要關註數據和業務邏輯，不需要和UI或者控件打交道。UI想怎麼處理數據都由UI自己決定，ViewModel不涉及任何和UI相關的事，也不持有UI控件的引用。即便是控件改變了（比如：TextView換成EditText），ViewModel也幾乎不需要更改任何代碼，完美解了View層和ViewModel。</p><h2 id="2-構建MVVM應用程式"><a href="#2-構建MVVM應用程式" class="headerlink" title="2.構建MVVM應用程式"></a>2.構建MVVM應用程式</h2><p>各層分工如下</p><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>隻做UI相關工作，在XML、Activity和Fragment寫View層的代碼，更新UI是通過數據綁定實現，盡量在VM裏麵做（更新綁定的數據源即可），Activity要做的事就是初始化一些控件（如控件的顔色，添加RecyclerView的分割線），V層可以處理事件（但是我們更希望UI事件通過Command來綁定）。簡單地說：V層不做任何業務邏輯、不涉及操作數據、不處理數據，UI和數據嚴格的分開。</p><h4 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h4><p>VM只做和業務邏輯和業務數據相關的事，不會持有任何控件的引用，更不會在VM中通過UI控件的引用去做更新UI的事情。VM就是專註於業務的邏輯處理，做的事情也都只是對數據的操作（這些數據綁定在相應的控件上會自動去更改UI）。同時DataBinding框架已經支援雙嚮綁定，讓我們可以通過雙嚮綁定獲取V層反饋給VM層的數據，並對這些數據上進行操作。關於對UI控件事件的處理，我們通過BindingAdapter對一些常用的事件封裝成一個個Command，對於每個事件我們用一個ReplyCommand去處理，ReplyCommand會把你可能需要的數據帶給你，這使得我們在VM層處理事件的時候只需要關心處理數據就行了</p><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>M層的任務是數據的獲取、存儲、狀態變化。M層包括實體模型（Bean）、Retrofit的Service ，獲取網路數據接口，在地存儲（增刪改查）接口，數據變化監聽等。Model提供數據獲取接口供VM調用，經數據轉換和操作並最終映射綁定到V層某個UI元素的屬性上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代碼精進之路-筆記</title>
      <link href="/2019/04/02/%E4%BB%A3%E7%A2%BC%E7%B2%BE%E9%80%B2%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/04/02/%E4%BB%A3%E7%A2%BC%E7%B2%BE%E9%80%B2%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>閱讀極客時間-代碼精進之路，將一些重點項目記錄如下<br></p><p>不要過份認為自己的代碼不會犯錯，就連apple的工程師都會犯下低級錯誤<br><br>以下是apple 著名的<font color="red"> GoToFail </font>漏洞</p><pre><code>    if ((error = doSomething()) != 0)        goto fail;        goto fail;    if ((error= doMore()) != 0)        goto fail;fail:    return error;</code></pre><h3 id="‘好’的代碼"><a href="#‘好’的代碼" class="headerlink" title="‘好’的代碼"></a>‘好’的代碼<br></h3><ul><li>容易理解<br></li><li>有明顯的安全問題<br></li><li>能夠滿足最關鍵的需求<br></li><li>有充分的註釋<br></li><li>使用規範的命名<br></li><li>經過充分的測試<br><br><font color="green">最適合當前現實環境的代碼，才是最優秀的代碼 </font><br></li></ul><h3 id="‘壞’的代碼"><a href="#‘壞’的代碼" class="headerlink" title="‘壞’的代碼"></a>‘壞’的代碼<br></h3><ul><li>難以閱讀的代碼<br></li><li>浪費大量計算機資源的代碼<br></li><li>代碼風格混亂的代碼<br></li><li>複雜的、不直觀的代碼<br></li><li>沒有經過適當測試的代碼<br></li></ul><h3 id="盡量不要使用條件運算符，而使用條件語句"><a href="#盡量不要使用條件運算符，而使用條件語句" class="headerlink" title="盡量不要使用條件運算符，而使用條件語句"></a>盡量不要使用條件運算符，而使用條件語句</h3><p>條件語句 <font color="green"> ○ </font></p><pre><code>if (variable != null) {   return variable.getSomething();}return null;</code></pre><p>條件運算符 <font color="red"> X </font></p><pre><code>return variable != null ? variable.getSomething() : null;</code></pre><hr><h2 id="代碼檢查的五道關卡"><a href="#代碼檢查的五道關卡" class="headerlink" title="代碼檢查的五道關卡"></a>代碼檢查的五道關卡</h2><h4 id="第一道關：程序員-好的代碼風格"><a href="#第一道關：程序員-好的代碼風格" class="headerlink" title="第一道關：程序員 (好的代碼風格) "></a>第一道關：程序員 (好的代碼風格) <br></h4><p>代碼縮進 </p><pre><code>    if ((error = doSomething()) != 0)        goto fail;    goto fail;    if ((error= doMore()) != 0)        goto fail;fail:    return error;</code></pre><p>使用大括號 </p><pre><code>    if ((error = doSomething()) != 0) {        goto fail;        goto fail;    }    if ((error= doMore()) != 0) {        goto fail;    }fail:    return error;</code></pre><h4 id="第二道關：編譯器"><a href="#第二道關：編譯器" class="headerlink" title="第二道關：編譯器"></a>第二道關：編譯器</h4><p>至今，GCC 社區對於無法訪問代碼的檢查，還沒有統一的意見 。然而，GCC 社區並沒有完全浪費這個“GoTo Fail”的問題 。為解決類似問題，從 GCC 6 開始，GCC 社區為正確使用縮進提供了一個警告選項（ -Wmisleading-indentation ）。如果代碼縮進格式沒有正確使用，GCC 就會提供編譯時警告。現在，如果我們啓用並且注意到了 GCC 編譯器的警告，犯類似錯誤的機會應該會大幅度地降低了。</p><h4 id="第三道關：回歸測試-（Regression-Testing）"><a href="#第三道關：回歸測試-（Regression-Testing）" class="headerlink" title="第三道關：回歸測試 （Regression Testing）"></a>第三道關：回歸測試 （Regression Testing）</h4><p>軟體測試會盡可能的覆蓋 關鍵邏輯和負面清單 ，以確保關鍵功能能夠正確執行，關鍵錯誤能夠有效處理。一般情況下，無論是開發人員，還是測試人員，都要寫很多測試代碼，來測試軟體是否達到預期的要求。</p><h4 id="第四道關：代碼評審-（Code-Review）"><a href="#第四道關：代碼評審-（Code-Review）" class="headerlink" title="第四道關：代碼評審 （Code Review）"></a>第四道關：代碼評審 （Code Review）</h4><p>代碼評審是一個有效的在軟體研發過程中抵禦人類缺陷的制度。通過更多的眼睛檢查軟體代碼，被忽視的錯誤更容易被逮住，更好的設計和實現更容易浮現出來。</p><h4 id="第五道關：代碼分析-（Code-Analysis）"><a href="#第五道關：代碼分析-（Code-Analysis）" class="headerlink" title="第五道關：代碼分析 （Code Analysis）"></a>第五道關：代碼分析 （Code Analysis）</h4><p>靜態代碼分析（Static Code Analysis）是通過對源代碼的檢查來發現潛在問題的一種軟體質量保障方式。有很多靜態代碼分析工具可以幫助你檢查代碼缺陷，比如說商業軟體 Coverity，以及開源軟體 FindBugs。</p><hr><h2 id="代碼規範的價值"><a href="#代碼規範的價值" class="headerlink" title="代碼規範的價值"></a>代碼規範的價值</h2><p>規範的代碼，可以降低代碼出錯的幾率，詳細內容請閱讀<a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener"> 阿里巴巴 Java 開發手冊 </a></p><h3 id="如何给你的代码起好名字？"><a href="#如何给你的代码起好名字？" class="headerlink" title="如何给你的代码起好名字？"></a>如何给你的代码起好名字？</h3><p>比如说，对于答案只有是与非两个选择的时候，我们通常使用布尔类型（boolean）。所以，取名字的时候，我们通常需要一个表达疑问的前缀，比如是不是“is”。</p><pre><code>public boolean isEmpty();     // String.isEmpty()</code></pre><p>但如果我们把这样的疑问前缀，使用到一个非布尔类型上，会有什么效果？</p><pre><code>public byte[] isEmpty();</code></pre><p>名字就是沟通的方式，错误的命名很难让我们清楚地理解代码真实的意图。所以，混淆的命名很难让我们阅读和理解代码。</p><p>所以使用一个好的命名规范是非常重要的，我们都能获得哪些好处呢？</p><ul><li>1.为标识符提供附加的信息，赋予标识符现实意义。帮助我们理顺编码的逻辑，减少阅读和理解代码的工作量；</li><li>2.使代码审核变得更有效率，专注于更重要的问题，而不是争论语法和命名规范这类小细节，提高开发效率；</li><li>3.提高代码的清晰度、可读性以及美观程度；</li><li>4.避免不同产品之间的命名冲突。</li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 代碼精進之路 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
