<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>極簡數據結構(1)-語言基礎</title>
      <link href="/2019/04/02/%E6%A5%B5%E7%B0%A1%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B(1)-%E8%AA%9E%E8%A8%80%E5%9F%BA%E7%A4%8E/"/>
      <url>/2019/04/02/%E6%A5%B5%E7%B0%A1%E6%95%B8%E6%93%9A%E7%B5%90%E6%A7%8B(1)-%E8%AA%9E%E8%A8%80%E5%9F%BA%E7%A4%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="1-輸入輸出"><a href="#1-輸入輸出" class="headerlink" title="1.輸入輸出"></a>1.輸入輸出</h2><pre><code>import java.util.Scanner;public class test {    public static void main(String[] args) {        Scanner input = new Scanner(System.in);         System.out.print(&quot;Enter an integer A: &quot;); //output        int numberA = input.nextInt();    //input        System.out.print(&quot;Enter an integer B: &quot;);        int numberB = input.nextInt();        System.out.println(&quot;A+B = &quot; + (numberA+numberB));    }}</code></pre><h2 id="2-String簡單使用"><a href="#2-String簡單使用" class="headerlink" title="2.String簡單使用"></a>2.String簡單使用</h2><pre><code>import java.util.Scanner;public class test {    public static void main(String[] args) {        Scanner input = new Scanner(System.in);        System.out.print(&quot;Enter an String A: &quot;);        String stringA = input.nextLine();        System.out.print(&quot;Enter an String B: &quot;);        String stringB = input.nextLine();        System.out.println(&quot;String A size = &quot; + stringA.length()); //string a length        System.out.println(&quot;String B size = &quot; + stringB.length());        System.out.println(&quot;String A + String B = &quot; + (stringA+stringB)); // string a + string b    }}</code></pre><h2 id="3-array-amp-vector"><a href="#3-array-amp-vector" class="headerlink" title="3.array &amp; vector"></a>3.array &amp; vector</h2><pre><code>import java.util.*;public class test {    public static void main(String[] args) {            final int arraySize = 10; //const            final int vectorSize = 5; //const            int[] array = new int[arraySize]; //create array            Vector v = new Vector(vectorSize); //create vector            for (int i = 0; i &lt; array.length ; i++) //array assign value                array[i] = i;            for (int i = 0; i &lt; array.length ; i++)                System.out.println(&quot;array[&quot;+i+&quot;]:&quot;+ array[i]);//get array and print            System.out.println(&quot;array:&quot;+Arrays.toString(array));//array to string and print            for (int i = 0; i &lt; v.capacity() ; i++) //vector assign value                v.add(i,i);            for (int i = 0; i &lt; v.capacity() ; i++)                //v.set(i, i); //沒有預設值即為null，null不能進行 set                System.out.println(&quot;Vector[&quot;+i+&quot;]:&quot;+ v.elementAt(i));//get vector element and print            System.out.println(&quot;Vector:&quot;+ v.toString());//print vector        }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 數據結構 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android面試(1)</title>
      <link href="/2019/04/02/Android%E9%9D%A2%E8%A9%A6(1)/"/>
      <url>/2019/04/02/Android%E9%9D%A2%E8%A9%A6(1)/</url>
      
        <content type="html"><![CDATA[<p>參考資料<br><br><a href="https://www.jianshu.com/p/718aa3c1a70b" target="_blank" rel="noopener">https://www.jianshu.com/p/718aa3c1a70b</a><br><br><a href="https://www.jianshu.com/p/602b1ec4ca7a" target="_blank" rel="noopener">https://www.jianshu.com/p/602b1ec4ca7a</a><br><br><a href="https://developer.android.com/guide/components/activities?hl=zh-tw" target="_blank" rel="noopener">https://developer.android.com/guide/components/activities?hl=zh-tw</a><br><br><a href="https://developer.android.com/guide/components/activities/activity-lifecycle" target="_blank" rel="noopener">https://developer.android.com/guide/components/activities/activity-lifecycle</a></p><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="一般生命周期"><a href="#一般生命周期" class="headerlink" title="一般生命周期"></a>一般生命周期</h2><p><img src="https://images0.cnblogs.com/blog/720086/201502/081829527828735.png" alt="lifecycle"></p><h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate():"></a>onCreate():</h3><p>状态：Activit 正在创建<br><br>任务：做初始化工作，如setContentView界面资源、初始化数据<br><br>注意：此方法的传参Bundle为该Activity上次被异常情况销毁时保存的状态信息。<br><br>補充說明:Activity若異常銷毀，狀態可保存在onSaveInstanceState<br><a href="https://blog.csdn.net/cheneasternsun/article/details/80721790" target="_blank" rel="noopener">https://blog.csdn.net/cheneasternsun/article/details/80721790</a></p><h3 id="onStart"><a href="#onStart" class="headerlink" title="onStart():"></a>onStart():</h3><p>状态：Activity 正在启动，这时Activity 可见但不在前台，无法和用户交互。</p><h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume():"></a>onResume():</h3><p>状态：Activity 获得焦点，此时Activity 可见且在前台并开始活动。</p><h3 id="onPause"><a href="#onPause" class="headerlink" title="onPause():"></a>onPause():</h3><p>状态： Activity 正在停止<br><br>任务：可做 数据存储、停止动画等操作。<br><br>注意：Activity切换时，旧Activity的onPause会先执行，然后才会启动新的Activity。</p><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop():"></a>onStop():</h3><p>状态：Activity 即将停止<br><br>任务：可做稍微重量级回收工作，如取消网络连接、注销广播接收器等。<br><br>注意：新Activity是透明主题时，旧Activity都不会走onStop。</p><h3 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy():"></a>onDestroy():</h3><p>状态：Activity 即将销毁<br><br>任务：做回收工作、资源释放。</p><h3 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart():"></a>onRestart():</h3><p>状态：Activity 重新启动，Activity由后台切换到前台，由不可见到可见。</p><p>a.完整生命周期：<br>onCreate()和onDestroy()之间所经历的。<br><br>b.可见生命周期：<br>onStart()和onStop()之间所经历的。<br>活动对于用户是可见的，但不可交互。<br><br>c.前台生命周期：<br>onResume()和onPause()之间所经历的。<br>活动可见，且可交互。</p><h2 id="異常生命周期"><a href="#異常生命周期" class="headerlink" title="異常生命周期"></a>異常生命周期</h2><h3 id="onSaveInstanceState和onRestoreInstanceState"><a href="#onSaveInstanceState和onRestoreInstanceState" class="headerlink" title="onSaveInstanceState和onRestoreInstanceState"></a>onSaveInstanceState和onRestoreInstanceState</h3><ul><li>出现时机：异常 情况下Activity 重建，非用户主动去销毁</li><li>系统异常终止时，调用onSavaInstanceState来保存状态。该方法调用在onStop之前，但和onPause没有时序关系。</li><li>onSaveInstanceState用於对临时性状态的保存(系统缓存)，而onPause用於对数据的持久化保存(persistent data)。</li><li>Activity被重新创建时，调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。</li><li>onSaveInstanceState-&gt;onPause-&gt;onStop-&gt;onDestroy-&gt;onCreate-&gt;onStart-&gt;onRestoreInstanceState-&gt;onResume</li></ul><h2 id="Activity生命周期的切换过程"><a href="#Activity生命周期的切换过程" class="headerlink" title="Activity生命周期的切换过程"></a>Activity生命周期的切换过程</h2><h3 id="启动Activity："><a href="#启动Activity：" class="headerlink" title="启动Activity："></a>启动Activity：</h3><p>onCreate()–&gt;onStart()–&gt;onResume()</p><h3 id="打开一个新Activity："><a href="#打开一个新Activity：" class="headerlink" title="打开一个新Activity："></a>打开一个新Activity：</h3><p>舊A onPause() –&gt;新A onCreate()–&gt;onStart()–&gt;onResume()–&gt;舊A onStop()</p><h3 id="返回到舊Activity："><a href="#返回到舊Activity：" class="headerlink" title="返回到舊Activity："></a>返回到舊Activity：</h3><p>新A onPause() –&gt;舊A onRestart()–&gt;onStart()–&gt;onResume()–&gt;新A onStop()–&gt;onDestory();</p><h3 id="Activity1上弹出对话框Activity2："><a href="#Activity1上弹出对话框Activity2：" class="headerlink" title="Activity1上弹出对话框Activity2："></a>Activity1上弹出对话框Activity2：</h3><p>A1 onPause()–&gt;A2 onCreate()–&gt;onStart()–&gt;onResume()</p><h3 id="关闭屏幕-按Home键："><a href="#关闭屏幕-按Home键：" class="headerlink" title="关闭屏幕/按Home键："></a>关闭屏幕/按Home键：</h3><p>A2 onPause()–&gt;onStop()–&gt;A1 onStop()</p><h3 id="点亮屏幕-回到前台："><a href="#点亮屏幕-回到前台：" class="headerlink" title="点亮屏幕/回到前台："></a>点亮屏幕/回到前台：</h3><p>A2 onRestart()–&gt;onStart()–&gt;A1 onRestart()–&gt;onStart()–&gt;A2 onResume()</p><h3 id="关闭对话框Activity2："><a href="#关闭对话框Activity2：" class="headerlink" title="关闭对话框Activity2："></a>关闭对话框Activity2：</h3><p>A2 onPause()–&gt;A1 onResume()–&gt;A2 onStop()–&gt;onDestroy()</p><h3 id="销毁Activity1："><a href="#销毁Activity1：" class="headerlink" title="销毁Activity1："></a>销毁Activity1：</h3><p>onPause()–&gt;onStop()–&gt;onDestroy()</p><h2 id="應用問題"><a href="#應用問題" class="headerlink" title="應用問題"></a>應用問題</h2><h3 id="Q-onStart-和onResume-onPause-和onStop-的区别？"><a href="#Q-onStart-和onResume-onPause-和onStop-的区别？" class="headerlink" title=" Q.onStart()和onResume()/onPause()和onStop()的区别？ "></a><font color="red"> Q.onStart()和onResume()/onPause()和onStop()的区别？ </font></h3><p>A.<br><br>onStart()与onStop()是从Activity是否可见進行调用<br><br>onResume()和onPause()是从Activity是否显示在前台進行調用</p><h3 id="Q-Activity-A启动另一个Activity-B会回调哪些方法？如果Activity-B是完全透明呢？如果启动的是一个对话框Activity呢？"><a href="#Q-Activity-A启动另一个Activity-B会回调哪些方法？如果Activity-B是完全透明呢？如果启动的是一个对话框Activity呢？" class="headerlink" title=" Q.Activity A启动另一个Activity B会回调哪些方法？如果Activity B是完全透明呢？如果启动的是一个对话框Activity呢？ "></a><font color="red"> Q.Activity A启动另一个Activity B会回调哪些方法？如果Activity B是完全透明呢？如果启动的是一个对话框Activity呢？ </font></h3><p>A.<br><br>1.A的onPause()-&gt;B的onCreate()-&gt;onStart()-&gt;onResume()-&gt;A的onStop()<br><br>2.最后不会调用Activity A的onStop()<br><br>3.如上2</p><h3 id="Q-onSaveInstanceState-方法？何时会调用？"><a href="#Q-onSaveInstanceState-方法？何时会调用？" class="headerlink" title="Q.onSaveInstanceState()方法？何时会调用？ "></a><font color="red">Q.onSaveInstanceState()方法？何时会调用？ </font></h3><p>A.<br><br>当非人为终止Activity时，比如系统配置发生改变时导致Activity被杀死并重新创建、资源内存不足导致低优先级的Activity被杀死，会调用 onSavaInstanceState() 来保存状态。该方法调用在onStop之前，但和onPause没有时序关系。</p><h3 id="Q：onSaveInstanceState-与onPause-的区别？"><a href="#Q：onSaveInstanceState-与onPause-的区别？" class="headerlink" title="Q：onSaveInstanceState()与onPause()的区别？ "></a><font color="red">Q：onSaveInstanceState()与onPause()的区别？ </font></h3><p>A.<br><br>onSaveInstanceState()适用于对临时性状态的保存，而onPause()适用于对数据的持久化保存。</p><h3 id="Q：如何避免配置改变时Activity重建？"><a href="#Q：如何避免配置改变时Activity重建？" class="headerlink" title="Q：如何避免配置改变时Activity重建？"></a><font color="red">Q：如何避免配置改变时Activity重建？</font></h3><p>A.<br><br>在AndroidManifest.xml中对应的Activity中设置android:configChanges=”orientation|screenSize”。此时再次旋转屏幕时，该Activity不会被系统杀死和重建，只会调用onConfigurationChanged。</p><h3 id="Q：优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？"><a href="#Q：优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？" class="headerlink" title="Q：优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？"></a><font color="red">Q：优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？</font></h3><p>A.<br><br>优先级低的Activity在内存不足被回收后重新打开会引发Activity重建。重新创建时会调用onRestoreInstanceState（该方法在onStart之后），并将onSavaInstanceState保存的Bundle对象作为参数传到onRestoreInstanceState与onCreate方法。因此可通过onRestoreInstanceState(Bundle savedInstanceState)和onCreate((Bundle savedInstanceState)来判断Activity是否被重建，并取出数据进行恢复。但需要注意的是，在onCreate取出数据时一定要先判断savedInstanceState是否为空。另外，谷歌更推荐使用onRestoreInstanceState进行数据恢复。</p><h3 id="Q：说下Activity的四种启动模式？（有时会出个实际问题来分析返回栈中Activity的情况）"><a href="#Q：说下Activity的四种启动模式？（有时会出个实际问题来分析返回栈中Activity的情况）" class="headerlink" title="Q：说下Activity的四种启动模式？（有时会出个实际问题来分析返回栈中Activity的情况）"></a><font color="red">Q：说下Activity的四种启动模式？（有时会出个实际问题来分析返回栈中Activity的情况）</font></h3><p>A.<br></p><ul><li>standard：每次启动Activity就会创建新的实例，並放入任務棧中</li><li>singleTop：FLAG_ACTIVITY_SINGLE_TOP，若Activity已经位于任务栈的栈顶，就不会重新创建直接使用，并回调 onNewIntent(intent)，若不在棧顶就創建新實例，例如閱讀類App的內容頁面。</li><li>singleTask：FLAG_ACTIVITY_NEW_TASK，若Activity在任务栈中存在，就不会重新创建直接使用，并回调 onNewIntent(intent) 方法，且讓實例回到棧顶，若不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，并把该Activity放进去；如果存在，就会创建到已经存在的栈中，使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</li><li>singleInstance：具有此模式的Activity只能单独位于一个任务栈中，且此任务栈中只有唯一实例，使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。</li></ul><h3 id="Q：如何启动其他应用的Activity？（有时会出个实际问题来分析返回栈中Activity的情况）"><a href="#Q：如何启动其他应用的Activity？（有时会出个实际问题来分析返回栈中Activity的情况）" class="headerlink" title="Q：如何启动其他应用的Activity？（有时会出个实际问题来分析返回栈中Activity的情况）"></a><font color="red">Q：如何启动其他应用的Activity？（有时会出个实际问题来分析返回栈中Activity的情况）</font></h3><p>A.<br></p><pre><code>Intent intent = new Intent();ComponentName cn = new ComponentName(&quot;package name&quot;,&quot;class name&quot;);intent.setComponent(cn);intent.setAction(&quot;android.intent.action.MAIN&quot;);startActivityForResult(intent, RESULT_OK);</code></pre><h3 id="Q：Activity的启动过程？（有时会出个实际问题来分析返回栈中Activity的情况）"><a href="#Q：Activity的启动过程？（有时会出个实际问题来分析返回栈中Activity的情况）" class="headerlink" title="Q：Activity的启动过程？（有时会出个实际问题来分析返回栈中Activity的情况）"></a><font color="red">Q：Activity的启动过程？（有时会出个实际问题来分析返回栈中Activity的情况）</font></h3><p>A.<br></p><ul><li>调用startActivity或者是startActivityForResult来开始</li><li>startActivity内部也是通过调用startActivityForResult来启动Activity，只不过传递的requestCode小于0</li><li>ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。</li><li>将当前系统栈顶的Activity执行onPause操作，ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法。</li><li>ActivityManagerService会继续执行启动Activity的逻辑，通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的main方法。</li><li>然后通知ActivityManagerService执行进程初始化操作，並同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作；</li><li>ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法。</li><li>ActivityManagerService onResume执行完成，<br>ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread执行真正的onStop方法。</li></ul><p><a href="https://blog.csdn.net/qq475703980/article/details/79701181" target="_blank" rel="noopener">https://blog.csdn.net/qq475703980/article/details/79701181</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android、面試 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC、MVP、MVVM 簡介</title>
      <link href="/2019/04/01/MVC%E3%80%81MVP%E3%80%81MVVM%20%E7%B0%A1%E4%BB%8B/"/>
      <url>/2019/04/01/MVC%E3%80%81MVP%E3%80%81MVVM%20%E7%B0%A1%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>參考資料<br><br><a href="https://tech.meituan.com/2016/11/11/android-mvvm.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/11/11/android-mvvm.html</a><br><br><a href="https://upday.github.io/blog/model-view-controller/" target="_blank" rel="noopener">https://upday.github.io/blog/model-view-controller/</a></p><h1 id="1-MVC、MVP、MVVM-架構模式-簡介"><a href="#1-MVC、MVP、MVVM-架構模式-簡介" class="headerlink" title="1.MVC、MVP、MVVM 架構模式 簡介"></a>1.MVC、MVP、MVVM 架構模式 簡介</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul><li>View：xml佈局文件</li><li>Model：實體模型（數據的獲取、存儲、數據狀態變化）</li><li>Controllor：Activity業務邏輯，數據處理和UI處理</li></ul><p>Controller同時擁有View跟Model，並且做為統整兩邊的橋樑的角色，故Controller的工作量大。<br>Android中代表View的XML視圖功能太弱，導致大量處理View的邏輯只能寫在Activity中，這樣Activity就充當了View和Controller兩個角色。</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><ul><li>View: Activity和XML，負責View的繪製以及與用戶的交互 </li><li>Model: 實體模型（數據的獲取、存儲、數據狀態變化）</li><li>Presenter: 負責完成View與Model間的交互和業務邏輯</li></ul><p>通過抽象的View與IPresenter接口，將Presenter與View進行解耦，透過接口進行操作，而不是直接操作View或Presenter層，從而讓Activity成為真正的View層。</p><p>弊端：<br><br>1.P層與V層是通過接口進行交互的，會存在大量接口代碼<br><br>2.以UI為驅動的模型，使用需考慮控件的引用、UI線程與Activity的生命周期<br><br>3.UI若改變，牽扯的更新UI的接口就必須得換<br><br>4.複雜的業務同時也可能會導致P層太大，代碼臃腫的問題依然不能解決</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul><li>Model: 實體模型（數據的獲取、存儲、數據狀態變化）</li><li>View: 對應於Activity和xml，負責View的繪製以及與用戶交互</li><li>ViewModel(VM): 負責完成View於Model間的交互,負責業務邏輯</li></ul><p>利用數據綁定(Data Binding)、依賴屬性(Dependency Property)、命令(Command)、路由事件(Routed Event)達成以下特性</p><h4 id="數據驅動"><a href="#數據驅動" class="headerlink" title="數據驅動"></a>數據驅動<br></h4><p>在MVVM中，數據變化後會自動更新UI，UI的改變也能自動反饋到數據層，數據成為主導因素。這樣MVVM層在業務邏輯處理中只要關心數據，不需要直接和UI打交道，在業務處理過程中簡單方便很多。</p><h4 id="低耦合度、可複用性、團隊協作容易"><a href="#低耦合度、可複用性、團隊協作容易" class="headerlink" title="低耦合度、可複用性、團隊協作容易"></a>低耦合度、可複用性、團隊協作容易<br></h4><p>數據和業務邏輯處於一個獨立的ViewModel中，ViewModel只需要關註數據和業務邏輯，不需要和UI或者控件打交道。UI想怎麼處理數據都由UI自己決定，ViewModel不涉及任何和UI相關的事，也不持有UI控件的引用。即便是控件改變了（比如：TextView換成EditText），ViewModel也幾乎不需要更改任何代碼，完美解了View層和ViewModel。</p><hr><h2 id="2-MVVM-各層分工如下"><a href="#2-MVVM-各層分工如下" class="headerlink" title="2.MVVM 各層分工如下"></a>2.MVVM 各層分工如下</h2><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>隻做UI相關工作，在XML、Activity和Fragment寫View層的代碼，更新UI是通過數據綁定實現，盡量在VM裏麵做（更新綁定的數據源即可），Activity要做的事就是初始化一些控件（如控件的顔色，添加RecyclerView的分割線），V層可以處理事件（但是我們更希望UI事件通過Command來綁定）。簡單地說：V層不做任何業務邏輯、不涉及操作數據、不處理數據，UI和數據嚴格的分開。</p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>VM只做和業務邏輯和業務數據相關的事，不會持有任何控件的引用，更不會在VM中通過UI控件的引用去做更新UI的事情。VM就是專註於業務的邏輯處理，做的事情也都只是對數據的操作（這些數據綁定在相應的控件上會自動去更改UI）。同時DataBinding框架已經支援雙嚮綁定，讓我們可以通過雙嚮綁定獲取V層反饋給VM層的數據，並對這些數據上進行操作。關於對UI控件事件的處理，我們通過BindingAdapter對一些常用的事件封裝成一個個Command，對於每個事件我們用一個ReplyCommand去處理，ReplyCommand會把你可能需要的數據帶給你，這使得我們在VM層處理事件的時候只需要關心處理數據就行了</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>M層的任務是數據的獲取、存儲、狀態變化。M層包括實體模型（Bean）、Retrofit的Service ，獲取網路數據接口，在地存儲（增刪改查）接口，數據變化監聽等。Model提供數據獲取接口供VM調用，經數據轉換和操作並最終映射綁定到V層某個UI元素的屬性上。</p><p>Ios MVVM 解決方案<br><br><a href="https://www.codementor.io/koromiko/mvvm-app-cl1wvw2sh" target="_blank" rel="noopener">https://www.codementor.io/koromiko/mvvm-app-cl1wvw2sh</a></p><p>Android MVVM 解決方案<br><br><a href="https://www.jianshu.com/p/996d76b2317f" target="_blank" rel="noopener">https://www.jianshu.com/p/996d76b2317f</a><br><br><a href="https://ithelp.ithome.com.tw/articles/10192829" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/articles/10192829</a></p><p>Flutter MVVM 解決方案<br><br><a href="https://www.jianshu.com/p/ae44ca90cde3" target="_blank" rel="noopener">https://www.jianshu.com/p/ae44ca90cde3</a><br><br><a href="https://cloud.tencent.com/developer/article/1372224" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1372224</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代碼精進之路-筆記</title>
      <link href="/2019/03/31/%E4%BB%A3%E7%A2%BC%E7%B2%BE%E9%80%B2%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/03/31/%E4%BB%A3%E7%A2%BC%E7%B2%BE%E9%80%B2%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>閱讀極客時間-代碼精進之路，將一些重點項目記錄如下<br></p><p>不要過份認為自己的代碼不會犯錯，就連apple的工程師都會犯下低級錯誤<br><br>以下是apple 著名的<font color="red"> GoToFail </font>漏洞</p><pre><code>    if ((error = doSomething()) != 0)        goto fail;        goto fail;    if ((error= doMore()) != 0)        goto fail;fail:    return error;</code></pre><h3 id="‘好’的代碼"><a href="#‘好’的代碼" class="headerlink" title="‘好’的代碼"></a>‘好’的代碼<br></h3><ul><li>容易理解<br></li><li>有明顯的安全問題<br></li><li>能夠滿足最關鍵的需求<br></li><li>有充分的註釋<br></li><li>使用規範的命名<br></li><li>經過充分的測試<br><br><font color="green">最適合當前現實環境的代碼，才是最優秀的代碼 </font><br></li></ul><h3 id="‘壞’的代碼"><a href="#‘壞’的代碼" class="headerlink" title="‘壞’的代碼"></a>‘壞’的代碼<br></h3><ul><li>難以閱讀的代碼<br></li><li>浪費大量計算機資源的代碼<br></li><li>代碼風格混亂的代碼<br></li><li>複雜的、不直觀的代碼<br></li><li>沒有經過適當測試的代碼<br></li></ul><h3 id="盡量不要使用條件運算符，而使用條件語句"><a href="#盡量不要使用條件運算符，而使用條件語句" class="headerlink" title="盡量不要使用條件運算符，而使用條件語句"></a>盡量不要使用條件運算符，而使用條件語句</h3><p>條件語句 <font color="green"> ○ </font></p><pre><code>if (variable != null) {   return variable.getSomething();}return null;</code></pre><p>條件運算符 <font color="red"> X </font></p><pre><code>return variable != null ? variable.getSomething() : null;</code></pre><hr><h2 id="代碼檢查的五道關卡"><a href="#代碼檢查的五道關卡" class="headerlink" title="代碼檢查的五道關卡"></a>代碼檢查的五道關卡</h2><h4 id="第一道關：程序員-好的代碼風格"><a href="#第一道關：程序員-好的代碼風格" class="headerlink" title="第一道關：程序員 (好的代碼風格) "></a>第一道關：程序員 (好的代碼風格) <br></h4><p>代碼縮進 </p><pre><code>    if ((error = doSomething()) != 0)        goto fail;    goto fail;    if ((error= doMore()) != 0)        goto fail;fail:    return error;</code></pre><p>使用大括號 </p><pre><code>    if ((error = doSomething()) != 0) {        goto fail;        goto fail;    }    if ((error= doMore()) != 0) {        goto fail;    }fail:    return error;</code></pre><h4 id="第二道關：編譯器"><a href="#第二道關：編譯器" class="headerlink" title="第二道關：編譯器"></a>第二道關：編譯器</h4><p>至今，GCC 社區對於無法訪問代碼的檢查，還沒有統一的意見 。然而，GCC 社區並沒有完全浪費這個“GoTo Fail”的問題 。為解決類似問題，從 GCC 6 開始，GCC 社區為正確使用縮進提供了一個警告選項（ -Wmisleading-indentation ）。如果代碼縮進格式沒有正確使用，GCC 就會提供編譯時警告。現在，如果我們啓用並且注意到了 GCC 編譯器的警告，犯類似錯誤的機會應該會大幅度地降低了。</p><h4 id="第三道關：回歸測試-（Regression-Testing）"><a href="#第三道關：回歸測試-（Regression-Testing）" class="headerlink" title="第三道關：回歸測試 （Regression Testing）"></a>第三道關：回歸測試 （Regression Testing）</h4><p>軟體測試會盡可能的覆蓋 關鍵邏輯和負面清單 ，以確保關鍵功能能夠正確執行，關鍵錯誤能夠有效處理。一般情況下，無論是開發人員，還是測試人員，都要寫很多測試代碼，來測試軟體是否達到預期的要求。</p><h4 id="第四道關：代碼評審-（Code-Review）"><a href="#第四道關：代碼評審-（Code-Review）" class="headerlink" title="第四道關：代碼評審 （Code Review）"></a>第四道關：代碼評審 （Code Review）</h4><p>代碼評審是一個有效的在軟體研發過程中抵禦人類缺陷的制度。通過更多的眼睛檢查軟體代碼，被忽視的錯誤更容易被逮住，更好的設計和實現更容易浮現出來。</p><h4 id="第五道關：代碼分析-（Code-Analysis）"><a href="#第五道關：代碼分析-（Code-Analysis）" class="headerlink" title="第五道關：代碼分析 （Code Analysis）"></a>第五道關：代碼分析 （Code Analysis）</h4><p>靜態代碼分析（Static Code Analysis）是通過對源代碼的檢查來發現潛在問題的一種軟體質量保障方式。有很多靜態代碼分析工具可以幫助你檢查代碼缺陷，比如說商業軟體 Coverity，以及開源軟體 FindBugs。</p><hr><h2 id="代碼規範的價值"><a href="#代碼規範的價值" class="headerlink" title="代碼規範的價值"></a>代碼規範的價值</h2><p>規範的代碼，可以降低代碼出錯的幾率，詳細內容請閱讀<a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener"> 阿里巴巴 Java 開發手冊 </a></p><h3 id="如何给你的代码起好名字？"><a href="#如何给你的代码起好名字？" class="headerlink" title="如何给你的代码起好名字？"></a>如何给你的代码起好名字？</h3><p>比如说，对于答案只有是与非两个选择的时候，我们通常使用布尔类型（boolean）。所以，取名字的时候，我们通常需要一个表达疑问的前缀，比如是不是“is”。</p><pre><code>public boolean isEmpty();     // String.isEmpty()</code></pre><p>但如果我们把这样的疑问前缀，使用到一个非布尔类型上，会有什么效果？</p><pre><code>public byte[] isEmpty();</code></pre><p>名字就是沟通的方式，错误的命名很难让我们清楚地理解代码真实的意图。所以，混淆的命名很难让我们阅读和理解代码。</p><p>所以使用一个好的命名规范是非常重要的，我们都能获得哪些好处呢？</p><ul><li>1.为标识符提供附加的信息，赋予标识符现实意义。帮助我们理顺编码的逻辑，减少阅读和理解代码的工作量；</li><li>2.使代码审核变得更有效率，专注于更重要的问题，而不是争论语法和命名规范这类小细节，提高开发效率；</li><li>3.提高代码的清晰度、可读性以及美观程度；</li><li>4.避免不同产品之间的命名冲突。</li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 代碼精進之路 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
